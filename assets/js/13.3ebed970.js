(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{417:function(a,t,r){"use strict";r.r(t);var s=r(44),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参数"}},[a._v("#")]),a._v(" 参数")]),a._v(" "),r("h3",{attrs:{id:"thisarg"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#thisarg"}},[a._v("#")]),a._v(" thisArg")]),a._v(" "),r("p",[a._v("必选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。")]),a._v(" "),r("h3",{attrs:{id:"argsarray"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#argsarray"}},[a._v("#")]),a._v(" argsArray")]),a._v(" "),r("p",[a._v("可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或  undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 浏览器兼容性 请参阅本文底部内容。")]),a._v(" "),r("h2",{attrs:{id:"返回值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回值"}},[a._v("#")]),a._v(" 返回值")]),a._v(" "),r("p",[a._v("调用有指定this值和参数的函数的结果。")]),a._v(" "),r("h2",{attrs:{id:"描述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[a._v("#")]),a._v(" 描述")]),a._v(" "),r("p",[a._v("在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。")]),a._v(" "),r("p",[a._v("apply 与 call() 非常相似，不同之处在于提供参数的方式。apply 使用参数数组而不是一组参数列表。apply 可以使用数组字面量（array literal），如 fun.apply(this, ['eat', 'bananas'])，或数组对象， 如  fun.apply(this, new Array('eat', 'bananas'))。")]),a._v(" "),r("p",[a._v("你也可以使用 arguments对象作为 argsArray 参数。 arguments 是一个函数的局部变量。 它可以被用作被调用对象的所有未指定的参数。 这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用arguments来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。")]),a._v(" "),r("p",[a._v("从 ECMAScript 第5版开始，可以使用任何种类的类数组对象，就是说只要有一个 length 属性和(0..length-1)范围的整数属性。例如现在可以使用 NodeList 或一个自己定义的类似 {'length': 2, '0': 'eat', '1': 'bananas'} 形式的对象。")]),a._v(" "),r("Vssue")],1)}),[],!1,null,null,null);t.default=e.exports}}]);